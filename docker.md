# DOCKER

* docker main components

* Comprehensive Guide to Docker Concepts ğŸš€ğŸ³
Docker has revolutionized the way we develop, ship, and run applications. It provides an open platform for developers and system administrators to build, ship, and run distributed applications on any system. This guide delves into essential Docker concepts and commands that every DevOps engineer should be familiar with. Let's dive in! ğŸŒŠ

## Docker Networking ğŸŒğŸ³
Docker Networking allows containers to communicate with each other and with external networks. It provides multiple networking modes:

#### Bridge:
The default mode, where containers connect to a private internal network on the host, allowing them to communicate with each other.

#### Host:
Removes network isolation between the container and the Docker host, using the hostâ€™s networking directly.

#### None:
Disables all networking for the container.

#### Overlay:
Enables swarm services to communicate with each other across nodes.

#### 
Macvlan: Assigns a MAC address to each container, making them appear as physical devices on the network.

#### 
Custom Networks: User-defined networks that allow for more complex scenarios, such as connecting containers across multiple hosts.

## Docker Volumes ğŸ“¦ğŸ”—
Docker Volumes are used to persist data generated by and used by Docker containers. They are stored on the host filesystem and can be shared among multiple containers. Types of volumes include:

#### Named Volumes:
Created and managed by Docker, stored in a specific location on the host.

#### Anonymous Volumes: 
Created when no name is specified, usually for temporary storage.

#### Host Volumes: 
Bind mounts that link specific paths on the host filesystem to paths in the container.

## Docker Compose ğŸ“ğŸ“¦
Docker Compose is a tool for defining and running multi-container Docker applications. With a docker-compose.yml file, you can specify:

Services: Define each container to be deployed.

Networks: Configure custom networks for the services.

Volumes: Specify data persistence and sharing between containers.

Commands include docker-compose up, docker-compose down, docker-compose build, and more.

## Docker Registry (Private & Public) ğŸ“šğŸ”ğŸ”“
Docker Registry is a storage and distribution system for Docker images. Key features include:

#### 
Public Registry: Like Docker Hub, accessible to everyone, allowing users to pull and push images.

#### Private Registry: 
Set up within an organization for secure storage and sharing of images. Can be hosted on-premises or using cloud services.

#### Dockerfile Instructions & Best Practices ğŸ› ï¸ğŸ“œ
A Dockerfile is a text document containing commands to assemble an image. Best practices include:

Minimize Layers: Combine commands to reduce the number of layers.

Use.dockerignore: Exclude unnecessary files from the build context.

Leverage Caching: Structure Dockerfile to maximize layer caching.

Avoidlatest Tag: Use specific version tags for better control over images.

#### Docker Containers ğŸ“¦ğŸ³
Docker Containers are lightweight, portable, and self-sufficient environments that include everything needed to run an application. They provide:

Isolation: Each container operates independently.

Portability: Containers can run consistently across different environments.

Efficiency: Share the host OS kernel, reducing overhead compared to VMs.

#### Docker Images ğŸ–¼ï¸ğŸ“¦
Docker Images are read-only templates used to create containers. They are built from a Dockerfile and can be:

Layered: Each instruction in the Dockerfile creates a layer.

Shared: Layers are shared between images, saving space and improving efficiency.

Distributed: Stored in registries and pulled by Docker engines to run containers.

## Docker Swarm VS Kubernetes âš”ï¸ğŸŒ
Docker Swarm and Kubernetes are orchestration tools for managing containerized applications:

Docker Swarm:

Integrated with Docker.

Simpler setup and maintenance.

Limited in features compared to Kubernetes.

Kubernetes:

More complex setup.

Rich feature set, including advanced scheduling, self-healing, and scaling.

Larger community and ecosystem support.

## VM Vs Docker ğŸ–¥ï¸ğŸ³
Virtual Machines (VMs) and Docker Containers differ in several ways:

VMs:

Provide hardware virtualization.

Include an entire OS, increasing resource usage.

Slower startup times.

Docker Containers:

Share the host OS kernel.

Lightweight and faster startup.

More efficient in resource usage.

Docker Logging & Monitoring ğŸ“‹ğŸ”
Docker provides built-in logging mechanisms to capture container logs. Monitoring tools like:

Prometheus: For collecting metrics.

Grafana: For visualizing metrics.

ELK Stack: For logging (Elasticsearch, Logstash, Kibana).

#### Steps to Containerize a Sample Application ğŸ› ï¸â¡ï¸ğŸ“¦
Steps include:

Write a Dockerfile: Define the application environment and dependencies.

Build the Image: Use docker build -t <image_name> . to create the image.

Run the Container: Use docker run -d -p <host_port>:<container_port> <image_name> to start the container.

Test the Application: Access the application via the exposed port to ensure it runs correctly.

Discuss Any Project Where You Used Docker & Why ğŸ’¬ğŸ³
Share a project where Docker was used to:

Containerize Applications: For consistency across development, testing, and production.

Streamline Development: Simplify environment setup and dependencies.

Simplify Deployment: Use Docker Compose or orchestration tools for deployment.

#### Cgroups & Namespaces ğŸ”’ğŸ› ï¸

Cgroups (Control Groups): Limit and isolate resource usage (CPU, memory, disk I/O) of containers.

Namespaces: Provide isolation of the systemâ€™s resources (processes, network, users), creating separate environments for each container.

Layered Architecture, Copy-on-Write, Writable Container Layer ğŸ“šğŸ“âœï¸
Docker images use a layered architecture where:

Base Layers: Shared across images to save space.

Copy-on-Write (CoW): Allows sharing of common files, modifying only when needed.

Writable Container Layer: Each container gets a writable layer on top of the read-only image layers.

#### Docker Commands ğŸ“œğŸ’»
Common Docker commands include:

docker run: Run a container.

docker build: Build an image from a Dockerfile.

docker ps: List running containers.

docker stop: Stop a running container.

docker rm: Remove a container.

docker pull: Pull an image from a registry.

docker push: Push an image to a registry.

#### Scanning Images for Vulnerabilities and Secrets ğŸ”ğŸ”
Use tools like:

##### Trivy:
For vulnerability scanning.

##### Clair: For static analysis of vulnerabilities.

Docker's Built-in Scanning: Integrated security scanning to detect vulnerabilities and secrets in Docker images.

How to Not Run the Container as the Root User ğŸš«ğŸ‘¤
To avoid running containers as root:

USER Instruction: Use the USER instruction in the Dockerfile to specify a non-root user.

--user Flag: Start the container with the --user flag to specify a user at runtime.

Optimizing the Docker Build Process âš¡ğŸ“¦
Optimize the Docker build process by:

Minimizing Layers: Combine commands to reduce the number of layers.

Multi-Stage Builds: Use multi-stage builds to reduce image size.

Leverage Cache: Structure Dockerfile to maximize layer caching.

Reduce Image Size: Use smaller base images and clean up unnecessary files to improve build times and performance.

[docker main components]()

## docker sheet sheet 

 ![docker](./Images/docker-cheetsheat.png)

[dockercommands](https://dockerlabs.collabnix.com/docker/cheatsheet/)


* Docker image and container : image nothing but package & container nothing but application . we want to build the package we required some  application .
* Container:software process created using OS virtualization  which  holds specific environment

![images](./Images/1.png)

Tower servers: designed put them on table/ground
Blade servers: arranged in racks  
DATABASE: data base not stores audios and videos it stores data of movies name , hero ,.......


![images](./Images/2.png)

We book  one ticket that ticket  number stores in database but the ticket booking pdf stores in objectstore.

Install: when ever you want to crome module systems(as user we update our whatsup)

Deploy:  take my application on some other place run on the servers (to give update on  organization )

In our ubuntu t2.micro instance we run one spring petclinic project but by using docker container  we run approximately 4 spring pet clinic projects. 
By using container we save our space & also continuous integration will be present on different ports.


Docker architecture 

Generation1: multiple services run by one network (monolithic)

Generation2: micro services (each server have different)cost is high

Generation3:docker (reducing cost )

Registry: collection of images hosted  for reuse is called registry

Dockershim: when we update the docker then also container will not stoped (it will be continuous to run)

OCI:(open container initiative)

 once the container is created the parent of the container will be dockershim.
To build docker image & container

### Docker image <command> < image>:<tag>

Docker image pull nginx : version

Ex: docker image pull busybox:3.15

To see the  all build images we use {docker image ls -q }

To see the run images only we use {docker image ls}


### Docker container <command> <container name>:<tags>

Docker container run/create nginx

RUN: to create and start the container

Hosts: itâ€™s machines which running on docker

Entrypont: its used as a arg (it will never change)

args: arguments nothing but variable

CMD : we give any image name it change the CMD its cannot effect the entrypoint

Start: to create the container

Remove container we use 

		 { docker container rm <containername>}

Remove al containers at a time 

		{docker container rm $(docker container ls -a -q )}

### Volume:

 when we delete the container total information can be deleted so we over come this problem to create the volumes

These volumes are two types those are

        explicitly(manually): docker volume created by ours
       Automatically:these volume created by docker

Volumes are two types 
### Bind mount: 

	  its connected b/w  file system to container
	   docker host nad container have same user that tim eonly we use bind mount .

	Ex: docker container run -d --name=hemacontaier --mount "source=/tmp , target=/tmp , type=bind" ubuntu:22.04 sleep 1d

	* bind mount is connected between files/m to docker container 


### Tmpfs mount:

 * its connected  between container to memory(ram)

### Volume:


 we give only source
### Mount:

 we give both source and destination

### Hosts:

 itâ€™s machines which running on docker 

### Entrypont
: 
its used as a arg (it will never change)
we cannot override the code

Cmd :
we can over ride the code & its acts as argument for entrypoint
 we give any image name it change the CMD its cannot effect the entrypoint (cmd used forrun the application )

### Networking: 

 (ifconfig  & sudo apt install net-tools)
 
 * we canâ€™t install the docker in our machine we have only two network interfaces those are eth0 & lo, when ever we install docker we check the network by using  ifconfig command add another n/w is docker0.

 	Eth0: its tell about which physically connected to the s/m
	Io:
	Docker0:   this docker0 network is created only the only in 172.17.0.1 to 255.255.0.0 ip ranges only 
        Lib:  its creates the network interface inside the container only (in these eth0 have docker0 configurations)
Docker networks are three types

### Bridge:


	we use different networks (we used for multiple machines)(we communicate both ip& name in bridge network but in default bridge network we give only ip addresses)

	* manually we create some subnet ranges

	Ex: docker network ls

		docker network create --subnet 192.168.1.0/24 network-name

		docker network create --subnet 192.168.1.0/24 --gateway 192.168.1.1 my-custom-network


		docker network create --driver host  hostnetwork-name

		docker network inspect network-name

		docker network connect network-name container-name/id





### Host:

	 we have same system where we create docker installed && local machine ip addresses asssigned to the bridge container , local vm subnet ranges will be used to create contaieer ip .


* incase container connected with host network we  can connect with bridge network the container ip will be changed.


### Null:

 no network

Drawbacks of docker0 is  itâ€™s not have DNS visible .

### BRIDGE N/W: 
 we move the containers from one network to othe network , in these
 -d  =  driver string
On bridge n/w we donâ€™t have volumes docker container build will be failed

### Phpmyadmin: 
is used for simple log web application
Once we create container we canâ€™t change volume(or ) mount
*docker container connects any number of containers by using host

DOCKERFILE: set of instructions

Name space:Docker uses namespaces of various kinds to provide the isolation that containers need in order to remain portable and refrain from affecting the remainder of the host system.


Alias
Alias delimage= â€˜docker image rm $(docker image ls -a -q)â€™

Alias delcontainer= â€˜docker container rm -f  $(docker container ls -a -q)â€™

Alias  prunevolume= â€˜docker volume prune $(docker volumels -a -q)â€™

We replace these alias command by delimage , delcontainer & prunevolume

### Dockerfile
	dockerfile is a test file . where we write set of instructions / directives to support to create a docker image

### docker image
	docker image is read only templet or file system which has the necessary files run our application inside the docker container

### docker container vs instance
	every container has isolated area to cannot destrub them
	in instance we can't run more applications (spc , gol ,....)

### namespace:
used to create isolated areas by using isolated areas containers cannot distrub the vm

### layers 
layes reducess the inefficiency in s/w deployments
container is a collection of layers
every run and copy/add commands form one layer

### dockershim:
	allows the kubelet to interact with docker , it's used for desired state

### docker oci:
	open container initiative(ex: like hal mark to containers)

### docker swarm :
	swarm is a container archistration to maintain the container .  k8sn is a best archistration of docker ; swarm has 2 containers 
		(1) manager (assigned work to worker node)
		(2) worker 
		in swarm any one works as a master or worker

### ci/cd pipeline

codebuildby developer

this build code is push into git repository

this code will pull by devops engineer

by using jenkins / azuredevops we build the code(build image)

test this image (automatic test is unit test)

image will scaned(by default software tool is snyk)

the image will be stored in docker hub ,or ECR or ACR 

for maintained desired state of container (we write docker or k8s yaml files)

using k8s to maintaine desired state and end user  can utilize our application continuously
(no down time )

![images](./Images/3.png)

![hema](./Images/4.png)

### name spaces
### micro- services design problem
### expose the application running inside docker to external world

### Running Docker Containers

#### Interactions

	* We can interact with running or stopped containers

	* attach: We will be able to connect to containers main processâ€™s STDIN/STDOUT/STDERR.

	* cp: This allows to send or recieve content to/from container

	* exec: Execute a command inside containersâ€™s isolation.

	* logs: Here we can review all the STDERR and STDOUT

* run jenkins container in detached mode

![hema](./Images/5.png)

* 		docker container logs de50fd695277/jenkins

*		docker container logs <container id>(or)<container name>

#### Copy files from docker host into contianer

![image](./Images/6.png)



### Limiting Host resources

*  Lets review some options for container resource consumption. We will be able to limit access to CPU,memory and block devices

*	hard limits: Thse represent container will not get more than declared value

* Container by default can consume all of host resources (no limits)


Options:

â€“cpu-period and â€“cpu-quota: This is specified in micro seconds and will modify cpu limits

â€“cpu-shares: This manages weight for containers main process. This is soft limit.

â€“cpus

â€“memory: maximum amount of memory for your container (hard limit)

â€“memory-reservation: this is soft limit

â€“blkio-weight

â€“blkio-weight-device 
* 

####  game of life application

* write pipeline for gol in azure -devops 

* and download gameoflife.war
* sftp 
* put gameoflife.war
* bye
* create docker container and copy the docker upload files
    
	docker container cp gameoflife.war <container-id>:/tmp/gameoflife.war

	docker container exec <container-id> /bin/bash

### NETWORKING

* three types of networkings are present in docker for single node containrs  those are

#### [1] null network

*  no network available in the containers

#### [2] host networks 

* host {instance} ip giving to the  container 

#### [3] bridge network

* in single instance more than one container then any 2 containers communicate by using bridge network . 
* by using any subnet id we can create these network
```
docker network ls

docker network create bridge --subnet <"any-subnet-id"> <name-of-the-network>

### container attached to the network

docker container run -d --name <name-ofthe-container> --network <network-name> httpd

docker exec <container-name> ping -c <any-number> 

### incase oci not support to the ping command inside container execute these commands

apt-get update
apt-get install iputils-ping -y


```

* using bridge n/w we can move the container from one n/w to another n/w

* docker network inspect network-name

* docker network create -d bridge --subnet 192.168.1.0/24 my-bridge alpine sleep d 

* docker container exec c2 ping -c 4 c3
		 
		 here c2 , c3 = containers 
		      c = howmany times we ping the container

* defalut bridge network containers communicate with ips only


### docker swarm 

* two containrs communicate with each other with 2 different vm 's at that time we use overlay network 


```yaml
version: '3.8'

services:
  gameoflife:
    image: gameoflife-image:latest
    container_name: gameoflife
    networks:
      - my-bridge-network
    depends_on:
      - mysql

  mysql:
    image: mysql:latest
    container_name: mysql
    environment:
      MYSQL_ROOT_PASSWORD: rootpassword
      MYSQL_DATABASE: gameoflife_db
      MYSQL_USER: user
      MYSQL_PASSWORD: userpassword
    volumes:
      - mysql-data:/var/lib/mysql
    networks:
      - my-bridge-network

networks:
  my-bridge-network:
    driver: bridge

volumes:
  mysql-data:

```
* docker compose up

* docker compose down

* docker image build -d image-name docker-file-path

* docker image pull image-name

* docker container run -d -P image-name

* docker contaier run -it -d image-name

* docker container exec -it container-id /bin/sh

* docker container stop container-id

* docker container kill/rm/prune <container-id>

* docker container rn -f $(docker container ls -a -q)

* docker container run -d -p 3000:80 httpd

	docker container exec -it httpd /bin/sh

	mkdir -p /ram/rahim/rabert

	cd /ram/rahim/rabert

	touch 1.txt

	echo "hai hemachaitanya dear" > 1.txt

* docker commit httpd-id username/imagename (this is use to create new changes include image from container)

* docker container logs container-id

* docker stats containr-id

* docker ps

* docker container run -d -P image-id/name --cpu=2Gi --memory=0.5Gb

* docker image save -o <hema.tar> image1 image2 image3

* get /home/ubuntu/hema.tar ~/.

* docker image load -i <hema.tar>

* docker attach <container-id>

* docker container cp 1.txt <container-name>:/tmp/

## git merge conflicts 

* how to accept gi-merge-conflicts 

![hema](./Images/mergeconflicts.png)
































